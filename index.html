<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Roguelite Yahtzee</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root{
            --accent-1: #ff4d4d;
            --accent-2: #ffec70;
            --accent-3: #ffb347;
            --bg-grad: linear-gradient(135deg, var(--accent-2) 0%, var(--accent-1) 100%);
        }
        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg-grad);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            color: #fff;
        }

        /* App layout */
        #app {
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            justify-content: center;
            padding: 18px;
            box-sizing: border-box;
        }

        header#header {
            width: 100%;
            max-width: 1100px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            pointer-events: auto;
        }

        .stats {
            display: flex;
            gap: 12px;
            align-items: center;
            color: #fff;
            text-shadow: 2px 2px 0 var(--accent-1), 0 0 8px var(--accent-2);
            font-size: 14px;
            flex-wrap: wrap;
        }

        .stat-pill {
            background: rgba(0,0,0,0.28);
            border: 2px solid rgba(255,255,255,0.08);
            padding: 8px 12px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            pointer-events: auto;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 8px 14px;
            border-radius: 8px;
            border: 2px solid var(--accent-1);
            cursor: pointer;
            background: var(--accent-2);
            color: var(--accent-1);
            transition: transform .08s ease, filter .12s ease;
        }
        .btn.secondary { background: var(--accent-1); color: #fff; border-color: var(--accent-2); }
        .btn:active { transform: translateY(1px) scale(0.995); }

        /* Canvas area */
        main.main {
            width: 100%;
            flex: 1 1 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .canvas-wrap {
            width: min(92vw, 960px);
            height: auto;
            background: rgba(0,0,0,0.08);
            padding: 18px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 12px;
        }
        #gameCanvas {
            background: #222;
            border: 10px solid var(--accent-1);
            image-rendering: pixelated;
            box-shadow: 0 0 36px var(--accent-2), 0 0 12px var(--accent-1);
            max-width: 100%;
            height: auto;
            display: block;
        }

        /* Deck UI */
        #deckUI { display:flex; gap:10px; align-items:center; justify-content:center; }
        .deck-slot { display:flex; flex-direction:column; align-items:center; gap:6px; }
        .deck-slot canvas { width:48px; height:48px; image-rendering: pixelated; border-radius:6px; }
        .deck-label { font-size:10px; color:#fff; text-shadow: 1px 1px 0 rgba(0,0,0,0.6); }

        /* Shop as right-side slide panel */
        #shop {
            position: fixed;
            top: 12px;
            right: 12px;
            width: min(360px, 90vw);
            height: calc(100% - 24px);
            background: #fff8e1;
            border: 4px solid var(--accent-1);
            border-radius: 12px;
            padding: 16px;
            display: none; /* controlled by JS */
            z-index: 1200;
            font-family: 'Press Start 2P', cursive;
            color: var(--accent-1);
            box-shadow: 0 8px 40px rgba(0,0,0,0.35);
            overflow: auto;
            transform: translateX(18px);
            transition: transform 280ms ease, opacity 200ms ease;
        }
        #shop.open { transform: translateX(0); }

        .shop-title { font-size: 16px; margin-bottom: 8px; color: var(--accent-1); }
        .shop-list { display: flex; flex-direction: column; gap: 10px; }
        .shop-item {
            margin: 0;
            cursor: pointer;
            background: linear-gradient(180deg,var(--accent-2),#ffe066);
            border: 2px solid var(--accent-1);
            border-radius: 8px;
            padding: 10px;
            transition: transform .12s ease, box-shadow .12s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .shop-item:hover { transform: translateY(-3px); box-shadow: 0 8px 18px rgba(0,0,0,0.12); }
        .shop-icon { width: 26px; height: 26px; }
        #closeShop { margin-top: 12px; }

        .muted { opacity: 0.6; }

        @media (max-width: 640px) {
            .stats { font-size: 12px; }
            .btn { font-size: 12px; padding: 6px 10px; }
            header#header { padding: 6px; }
            #shop { width: 92vw; left: 50%; right: auto; transform: translateX(50%); top: auto; bottom: 12px; height: auto; }
        }
    </style>
</head>
<body>
    <div id="app">
        <header id="header">
            <div class="stats">
                <div class="stat-pill"><span id="score">Score: 0</span></div>
                <div class="stat-pill"><span id="gold">Gold: 0</span></div>
                <div class="stat-pill"><span id="rerolls">Rerolls: 3</span></div>
                <div class="stat-pill"><span id="deck"></span></div>
                <div class="stat-pill"><span id="round">Round: 1</span></div>
            </div>
            <div class="controls">
                <button id="rollBtn" class="btn">Roll Dice</button>
                <button id="endRoundBtn" class="btn">End Round</button>
                <button id="shopBtn" class="btn secondary" disabled>Shop</button>
            </div>
        </header>

        <main class="main">
            <div class="canvas-wrap">
                <canvas id="gameCanvas" width="640" height="480"></canvas>
                <div id="deckUI" aria-hidden="false"></div>
            </div>
        </main>

        <aside id="shop" aria-hidden="true">
            <div class="shop-title">Shop</div>
            <div id="shopItems" class="shop-list"></div>
            <button id="closeShop" class="btn">Close</button>
        </aside>
    </div>
    <script>
        // --- Pixel Art Dice Sprites ---
        const diceSprites = {
            normal: [
                // 6x6 pixel art for each face (1-6)
                [
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                    [0,0,2,0,0,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                ],
                [
                    [0,0,0,0,0,0],
                    [0,2,0,0,0,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                ],
                [
                    [0,0,0,0,0,0],
                    [0,2,0,0,0,0],
                    [0,0,2,0,0,0],
                    [0,0,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                ],
                [
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                    [0,0,0,0,0,0],
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                ],
                [
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,0,2,0,0,0],
                    [0,0,0,0,0,0],
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                ],
                [
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                    [0,2,0,0,2,0],
                    [0,0,0,0,0,0],
                ]
            ],
            // Fire Die: Red border, burns for extra points
            fire: [
                // Same faces, but color code 3 for border
            ],
            // Lucky Die: Yellow border, reroll 1s
            lucky: [
                // Same faces, but color code 4 for border
            ],
            // Shield Die: Orange border, blocks negative effects
            shield: [
                // Same faces, but color code 5 for border
            ],
            // Frost Die: Light blue border, extra points on 5-6
            frost: [
                // Same faces, but color code 6 for border
            ],
            // Poison Die: Green border, negative effect on 1
            poison: [
                // Same faces, but color code 7 for border
            ],
            // Gold Die: Dark yellow border, extra gold on 5-6
            gold: [
                // Same faces, but color code 8 for border
            ],
            // Double Die: Pink border, doubles even rolls
            double: [
                // Same faces, but color code 9 for border
            ]
        };
        // Fill in fire/lucky/shield dice with colored borders
        function makeColoredDice(base, borderColor) {
            return base.map(face => face.map((row, y) =>
                row.map((cell, x) => {
                    if (x === 0 || x === 5 || y === 0 || y === 5) return borderColor;
                    return cell;
                })
            ));
        }
        diceSprites.fire = makeColoredDice(diceSprites.normal, 3);
        diceSprites.lucky = makeColoredDice(diceSprites.normal, 4);
        diceSprites.shield = makeColoredDice(diceSprites.normal, 5);
        diceSprites.frost = makeColoredDice(diceSprites.normal, 6);
        diceSprites.poison = makeColoredDice(diceSprites.normal, 7);
        diceSprites.gold = makeColoredDice(diceSprites.normal, 8);
        diceSprites.double = makeColoredDice(diceSprites.normal, 9);

        // --- Dice Definitions ---
        const diceTypes = [
            {
                name: "Normal Die",
                key: "normal",
                desc: "Standard die.",
                color: "#fff",
                unlock: 0,
                ability: (rolls, idx, state) => rolls[idx],
            },
            {
                name: "Fire Die",
                key: "fire",
                desc: "+2 bonus on 6.",
                color: "#ff4d4d",
                unlock: 10,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] === 6) state.bonus += 2;
                    return rolls[idx];
                }
            },
            {
                name: "Lucky Die",
                key: "lucky",
                desc: "Rerolls 1s.",
                color: "#ffec70",
                unlock: 20,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] === 1) {
                        let reroll = Math.floor(Math.random() * 6) + 1;
                        return reroll;
                    }
                    return rolls[idx];
                }
            },
            {
                name: "Shield Die",
                key: "shield",
                desc: "Blocks negative effects.",
                color: "#ffb347",
                unlock: 30,
                ability: (rolls, idx, state) => rolls[idx]
            },
            {
                name: "Frost Die",
                key: "frost",
                desc: "+3 bonus on 5 or 6.",
                color: "#8fd8ff",
                unlock: 12,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] >= 5) state.bonus += 3;
                    return rolls[idx];
                }
            },
            {
                name: "Poison Die",
                key: "poison",
                desc: "Rolling a 1 subtracts 2 score.",
                color: "#7a1f1f",
                unlock: 18,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] === 1) state.score = Math.max(0, state.score - 2);
                    return rolls[idx];
                }
            },
            {
                name: "Gold Die",
                key: "gold",
                desc: "5-6 yield extra gold.",
                color: "#ffd24d",
                unlock: 8,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] >= 5) state.gold += 1;
                    return rolls[idx];
                }
            },
            {
                name: "Double Die",
                key: "double",
                desc: "Even rolls are doubled.",
                color: "#ff9fba",
                unlock: 22,
                ability: (rolls, idx, state) => {
                    if (rolls[idx] % 2 === 0) return rolls[idx] * 2 > 6 ? 6 : rolls[idx] * 2;
                    return rolls[idx];
                }
            },
        ];

        // --- Game State ---
        let state = {
            score: 0,
            gold: 0,
            baseRerolls: 3,
            rerolls: 3,
            deck: [{type: "normal"}, {type: "normal"}, {type: "normal"}, {type: "normal"}, {type: "normal"}],
            unlocked: ["normal"],
            shopOpen: false,
            bonus: 0,
            anim: null,
            diceResults: [],
            round: 1,
            roundActive: true,
            upgrades: [],
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        // New helper to draw to arbitrary context (used for small deck canvases too)
        function drawPixelDieTo(ctxLocal, x, y, size, face, type) {
            const sprite = diceSprites[type] || diceSprites.normal;
            const s = Math.max(1, size/6);
            for (let py=0; py<6; ++py) {
                for (let px=0; px<6; ++px) {
                    let c = sprite[py][px];
                    if (c === 0) continue;
                    ctxLocal.fillStyle = (
                        c === 2 ? "#222" :
                        c === 3 ? "#ff4d4d" :
                        c === 4 ? "#ffec70" :
                        c === 5 ? "#ffb347" :
                        c === 6 ? "#8fd8ff" :
                        c === 7 ? "#6b8b3b" :
                        c === 8 ? "#ffd24d" :
                        c === 9 ? "#ff9fba" :
                        "#fff"
                    );
                    ctxLocal.fillRect(x+px*s, y+py*s, s, s);
                }
            }
            ctxLocal.strokeStyle = "#000";
            ctxLocal.lineWidth = 2;
            ctxLocal.strokeRect(x, y, size, size);
        }

        function drawPixelDie(x, y, size, face, type) {
            drawPixelDieTo(ctx, x, y, size, face, type);
        }

        function drawDiceRow(results, deck, animY=0) {
            let n = deck.length;
            let size = 64;
            let gap = 24;
            let startX = (W - (n*size + (n-1)*gap)) / 2;
            for (let i=0; i<n; ++i) {
                let dieType = deck[i].type;
                let face = results[i] || 1;
                drawPixelDie(startX + i*(size+gap), H/2 - size/2 + animY, size, face, dieType);
            }
        }

        // Render deck UI (small canvases)
        function renderDeckUI() {
            const container = document.getElementById('deckUI');
            container.innerHTML = '';
            state.deck.forEach((d, i) => {
                const slot = document.createElement('div');
                slot.className = 'deck-slot';
                const c = document.createElement('canvas');
                c.width = 48; c.height = 48;
                const localCtx = c.getContext('2d');
                localCtx.clearRect(0,0,48,48);
                const face = (state.diceResults[i]) ? state.diceResults[i] : 1;
                // draw centered
                drawPixelDieTo(localCtx, 2, 2, 44, face, d.type);
                const label = document.createElement('div');
                label.className = 'deck-label';
                label.textContent = d.type;
                slot.appendChild(c);
                slot.appendChild(label);
                container.appendChild(slot);
            });
        }

        function updateUI() {
            document.getElementById('score').textContent = `Score: ${state.score}`;
            document.getElementById('gold').textContent = `Gold: ${state.gold}`;
            document.getElementById('rerolls').textContent = `Rerolls: ${state.rerolls}`;
            document.getElementById('deck').textContent = `Deck: ${state.deck.map(d => diceTypes.find(dt=>dt.key===d.type).name).join(", ")}`;
            document.getElementById('round').textContent = `Round: ${state.round}`;
            // Shop access only at end of round
            const shopBtn = document.getElementById('shopBtn');
            shopBtn.disabled = state.roundActive;
            shopBtn.classList.toggle('muted', state.roundActive);
            document.getElementById('endRoundBtn').disabled = !state.roundActive;
            renderDeckUI();
        }

        // --- Animation ---
        function animateRoll(results, deck, callback) {
            let frames = 24;
            let animFrame = 0;
            function frame() {
                ctx.clearRect(0,0,W,H);
                // Animate dice "jumping"
                let animY = Math.sin(animFrame/frames * Math.PI) * 40;
                drawDiceRow(results.map(()=>Math.floor(Math.random()*6)+1), deck, animY);
                animFrame++;
                if (animFrame < frames) {
                    requestAnimationFrame(frame);
                } else {
                    ctx.clearRect(0,0,W,H);
                    drawDiceRow(results, deck, 0);
                    callback();
                }
            }
            frame();
        }

        function animateCelebration(results, deck, callback) {
            let frames = 32;
            let animFrame = 0;
            function frame() {
                ctx.clearRect(0,0,W,H);
                drawDiceRow(results, deck, 0);
                // Fireworks
                for (let i=0; i<10; ++i) {
                    let angle = Math.random()*2*Math.PI;
                    let r = Math.random()*80 + 40;
                    let x = W/2 + Math.cos(angle)*r;
                    let y = H/2 + Math.sin(angle)*r;
                    ctx.fillStyle = Math.random() > 0.5 ? "#ffec70" : "#ff4d4d";
                    ctx.globalAlpha = 1 - animFrame/frames;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2*Math.PI);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                animFrame++;
                if (animFrame < frames) {
                    requestAnimationFrame(frame);
                } else {
                    ctx.clearRect(0,0,W,H);
                    drawDiceRow(results, deck, 0);
                    callback();
                }
            }
            frame();
        }

        // --- Game Logic ---
        function rollDice() {
            state.bonus = 0;
            let results = [];
            for (let i=0; i<state.deck.length; ++i) {
                let roll = Math.floor(Math.random()*6)+1;
                results.push(roll);
            }
            // Apply dice abilities
            for (let i=0; i<state.deck.length; ++i) {
                let dieType = state.deck[i].type;
                let dieDef = diceTypes.find(dt=>dt.key===dieType) || diceTypes[0];
                results[i] = dieDef.ability(results, i, state);
            }
            state.diceResults = results;
            animateRoll(results, state.deck, () => {
                ctx.clearRect(0,0,W,H);
                drawDiceRow(results, state.deck, 0);
                let score = scoreYahtzee(results) + state.bonus;
                state.score += score;
                // gold per roll plus upgrades
                let goldGain = Math.floor(score/2);
                const extraGoldUpgrades = state.upgrades.filter(u=>u==='gold').length;
                goldGain += extraGoldUpgrades;
                state.gold += goldGain;
                updateUI();
                if (score >= 25) {
                    animateCelebration(results, state.deck, () => {});
                }
            });
        }

        function scoreYahtzee(results) {
            let counts = {};
            for (let v of results) counts[v] = (counts[v]||0)+1;
            let vals = Object.values(counts);
            let unique = Object.keys(counts).map(Number);
            unique.sort((a,b)=>a-b);
            if (vals.includes(5)) return 50; // Yahtzee
            if (vals.includes(4)) return 30;
            if (vals.includes(3) && vals.includes(2)) return 25; // Full house
            if (unique.join() === "1,2,3,4,5" || unique.join() === "2,3,4,5,6") return 40; // Large straight
            if (unique.length >= 4 && (
                unique.slice(0,4).join() === "1,2,3,4" ||
                unique.slice(1,5).join() === "2,3,4,5" ||
                unique.slice(2,6).join() === "3,4,5,6"
            )) return 30; // Small straight
            if (vals.includes(3)) return 20;
            return results.reduce((a,b)=>a+b,0);
        }

        // --- Shop pool ---
        const shopPool = [
            { name: "Refill Rerolls", desc: "Restore all rerolls for next round.", cost: 8, icon: "ðŸ”„", effect: () => { state.rerolls = state.baseRerolls; } },
            { name: "+1 Reroll Permanently", desc: "Increase base rerolls by 1.", cost: 14, icon: "âž•", effect: () => { state.baseRerolls += 1; } },
            { name: "Unlock Fire Die", desc: "Unlock Fire Die.", cost: 15, icon: "ðŸ”¥", effect: () => { if (!state.unlocked.includes('fire')) state.unlocked.push('fire'); } },
            { name: "Unlock Lucky Die", desc: "Unlock Lucky Die.", cost: 20, icon: "ðŸ€", effect: () => { if (!state.unlocked.includes('lucky')) state.unlocked.push('lucky'); } },
            { name: "Unlock Shield Die", desc: "Unlock Shield Die.", cost: 25, icon: "ðŸ›¡ï¸", effect: () => { if (!state.unlocked.includes('shield')) state.unlocked.push('shield'); } },
            { name: "Unlock Frost Die", desc: "Unlock Frost Die.", cost: 18, icon: "â„ï¸", effect: () => { if (!state.unlocked.includes('frost')) state.unlocked.push('frost'); } },
            { name: "Unlock Poison Die", desc: "Unlock Poison Die.", cost: 18, icon: "â˜ ï¸", effect: () => { if (!state.unlocked.includes('poison')) state.unlocked.push('poison'); } },
            { name: "Add Random Die", desc: "Add a random unlocked die to your deck.", cost: 12, icon: "ðŸŽ²", effect: () => { let t = state.unlocked[Math.floor(Math.random()*state.unlocked.length)]; state.deck.push({type: t}); } },
            { name: "Upgrade: +1 Gold per Roll", desc: "Earn more gold per roll.", cost: 18, icon: "ðŸ’°", effect: () => { state.upgrades.push('gold'); } },
            { name: "Replace Random Die", desc: "Replace a random die in your deck with a random unlocked die.", cost: 16, icon: "ðŸ”€", effect: () => { if (state.deck.length>0) { let idx = Math.floor(Math.random()*state.deck.length); let t = state.unlocked[Math.floor(Math.random()*state.unlocked.length)]; state.deck[idx] = {type: t}; } } },
            { name: "Mystery Box", desc: "Random effect (could be boon or small malus).", cost: 10, icon: "â“", effect: () => { const r = Math.random(); if (r<0.4) { state.gold += 5; } else if (r<0.7) { state.score += 10; } else { state.score = Math.max(0, state.score - 5); } } }
        ];

        function sampleShopOffers(count=5) {
            const pool = shopPool.slice();
            const offers = [];
            count = Math.min(count, pool.length);
            for (let i=0;i<count;i++) {
                const idx = Math.floor(Math.random()*pool.length);
                offers.push(pool.splice(idx,1)[0]);
            }
            return offers;
        }

        function openShop() {
            if (state.roundActive) return; // only at end of round
            state.shopOpen = true;
            const shopEl = document.getElementById('shop');
            shopEl.style.display = 'block';
            requestAnimationFrame(() => shopEl.classList.add('open'));
            shopEl.setAttribute('aria-hidden','false');
            const shopDiv = document.getElementById('shopItems');
            shopDiv.innerHTML = '';
            const offers = sampleShopOffers(5);
            offers.forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                div.innerHTML = `<span class="shop-icon">${item.icon}</span> <div style='flex:1;'><div style="font-weight:bold;color:var(--accent-1);">${item.name}</div><div style="font-size:11px;color:#333;">${item.desc}</div></div><div style="margin-left:8px;font-weight:bold;color:var(--accent-1);">${item.cost}G</div>`;
                div.onclick = () => {
                    if (state.gold >= item.cost) {
                        state.gold -= item.cost;
                        item.effect();
                        updateUI();
                        openShop(); // refresh offers (random)
                    } else {
                        // simple feedback
                        div.style.opacity = '0.5';
                        setTimeout(()=>div.style.opacity='1',200);
                    }
                };
                shopDiv.appendChild(div);
            });
        }
        function closeShop() {
            state.shopOpen = false;
            const shopEl = document.getElementById('shop');
            shopEl.classList.remove('open');
            shopEl.setAttribute('aria-hidden','true');
            setTimeout(() => { if (!state.shopOpen) shopEl.style.display = 'none'; }, 300);
            // start next round
            state.round++;
            state.roundActive = true;
            // refill rerolls with any permanent upgrades
            const extraRerollUpgrades = state.baseRerolls - 3; // base tracks perm growth
            state.rerolls = state.baseRerolls;
            updateUI();
        }

        // --- Event Listeners ---
        document.getElementById('rollBtn').onclick = () => {
            if (state.shopOpen) return;
            if (!state.roundActive) return;
            if (state.rerolls > 0) {
                state.rerolls--;
                rollDice();
                updateUI();
                if (state.rerolls <= 0) {
                    // automatically end round
                    state.roundActive = false;
                    updateUI();
                    // enable shop button
                    document.getElementById('shopBtn').disabled = false;
                    document.getElementById('shopBtn').classList.remove('muted');
                }
            }
        };
        document.getElementById('endRoundBtn').onclick = () => {
            if (!state.roundActive) return;
            state.roundActive = false;
            updateUI();
            // open shop automatically when round ends
            openShop();
        };
        document.getElementById('shopBtn').onclick = () => openShop();
        document.getElementById('closeShop').onclick = () => closeShop();

        // --- Initial Draw ---
        function mainLoop() {
            ctx.clearRect(0,0,W,H);
            drawDiceRow(state.diceResults.length ? state.diceResults : [1,1,1,1,1], state.deck, 0);
            requestAnimationFrame(mainLoop);
        }
        updateUI();
        mainLoop();

        // --- Unlock Dice with Score ---
        setInterval(() => {
            diceTypes.forEach(dt => {
                if (state.score >= dt.unlock && !state.unlocked.includes(dt.key)) {
                    state.unlocked.push(dt.key);
                }
            });
        }, 1000);

    </script>
</body>
</html>